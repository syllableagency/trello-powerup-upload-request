<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Customer Approval</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 14px; }
      .field { margin-bottom: 12px; }
      label { display:block; font-size: 13px; margin-bottom: 6px; }
      input[type="text"], select { width: 100%; padding: 8px; box-sizing: border-box; }
      input[type="file"] { width: 100%; }
      .drop-zone {
        border: 2px dashed #c8ccd0;
        border-radius: 8px;
        padding: 12px;
        background: #f6f8fa;
        color: #172b4d;
        cursor: pointer;
      }
      .drop-zone.active {
        border-color: #0c66e4;
        background: #e9f2ff;
      }
      .drop-zone.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .proof-box {
        border: 1px solid #e1e4e8;
        border-radius: 8px;
        padding: 10px;
      }
      .proof-option { margin-bottom: 8px; }
      .proof-option:last-child { margin-bottom: 0; }
      .row { display:flex; gap: 10px; }
      .row > div { flex: 1; }
      .actions { display:flex; gap: 10px; margin-top: 14px; }
      button { padding: 9px 12px; cursor: pointer; }
      .error { color: #b42318; font-size: 13px; margin-top: 8px; white-space: pre-line; }
      .note { color:#d1d1d1; font-size: 12px; margin-top: 6px; }
      .busy { opacity: 0.7; pointer-events:none; }
      .success { color: #1f7a1f; font-size: 13px; margin-top: 8px; }
      .hr { height: 1px; background: #e6e6e6; margin: 12px 0; }
    </style>
  </head>
  <body>
    <div id="authBlock" class="field" style="display:none;">
      <div class="note">
        This Power-Up needs permission to upload attachments and apply labels.
      </div>
      <div class="actions">
        <button id="btnAuthorize" type="button">Authorize</button>
        <button id="btnCloseA" type="button">Close</button>
      </div>
      <div id="authError" class="error"></div>
      <div class="hr"></div>
    </div>

    <form id="form">
      <div class="field">
        <label>
          <input id="approved" type="checkbox" required />
          This design has been approved by the customer
        </label>
      </div>

      <div class="row">
        <div class="field">
          <label for="companySelect">Customer Name (required)</label>
          <select id="companySelect" required>
            <option value="">Loading customers...</option>
          </select>
        </div>
        <div class="field" id="companyCustomField" style="display:none;">
          <label for="companyCustom">Enter Customer Name (required)</label>
          <input id="companyCustom" type="text" />
          <div class="note">This customer will be added to the customer list for future use.</div>
        </div>
        <div class="field">
          <label for="contact">Customer Contact Name (required)</label>
          <input id="contact" type="text" required />
        </div>
      </div>

      <div class="field">
        <label for="designParts">Design Part Name(s) / Number(s) (required)</label>
        <input id="designParts" type="text" required placeholder="Example: B2405, X44 Engine Skid, All designs..." />
      </div>

      <div class="field proof-box">
        <label>Approval Proof Method (required)</label>
        <label class="proof-option">
          <input id="proofUpload" name="proofMethod" type="radio" value="upload" checked />
          Upload proof file
        </label>
        <label class="proof-option">
          <input id="proofSign" name="proofMethod" type="radio" value="sign" />
          Digitally sign instead (adds a comment to the card)
        </label>
      </div>

      <div id="fileBlock" class="field">
        <label for="file">Upload approval file (required)</label>
        <div id="dropZone" class="drop-zone" tabindex="0" role="button" aria-controls="file">
          Drag and drop file(s) here, or click to choose file(s).
        </div>
        <input id="file" type="file" multiple />
        <div id="fileName" class="note"></div>
        <div class="note">This can be a signed print, screenshot of an email, or similar proof of customer approval.</div>
        <div class="note">This will be attached to the card as "Customer Approval Verification".</div>
      </div>

      <div id="signBlock" class="field" style="display:none;">
        <div class="note">
          No file upload will be required. A card comment will be added stating that you signed to confirm customer approval.
        </div>
      </div>

      <div class="actions">
        <button id="btnSubmit" type="submit">Mark Approved & Upload</button>
        <button id="btnClose" type="button">Cancel</button>
      </div>

      <div id="status" class="note"></div>
      <div id="error" class="error"></div>
      <div id="success" class="success"></div>
    </form>

    <script src="https://p.trellocdn.com/power-up.min.js"></script>
    <script>
      const queryParams = new URLSearchParams(window.location.search);
      const DEFAULT_APP_KEY = "51c30a2cb14666510ff4905d9d4eae07";
      const APP_KEY = queryParams.get("appKey") || DEFAULT_APP_KEY;
      const CACHE_VERSION = queryParams.get("v") || "";
      const APP_NAME = "Customer Approval Gatekeeper";
      const APP_AUTHOR = "Syllable Agency";

      const BASE_ATTACHMENT_NAME = "Customer Approval Verification";
      const APPROVED_LABEL_NAME = "Customer Approved";
      const APPROVED_LABEL_COLOR = "green";
      const PROOF_METHOD_UPLOAD = "upload";
      const PROOF_METHOD_SIGN = "sign";
      const DESTINATION_SETTINGS_KEY = "destinationSettings";
      const CUSTOMER_LIST_SETTINGS_KEY = "customerList";
      const DEFAULT_TARGET_LIST_ID = "5d1393e0184e28237c1a59a6";
      const CUSTOMER_NOT_LISTED = "NOT LISTED";
      const DEFAULT_CUSTOMERS_URL =
        `https://syllableagency.github.io/trello-powerup-upload-request/customers-default.json${CACHE_VERSION ? `?v=${encodeURIComponent(CACHE_VERSION)}` : ""}`;

      const t = window.TrelloPowerUp.iframe({
        appKey: APP_KEY,
        appName: APP_NAME,
        appAuthor: APP_AUTHOR
      });

      const $ = (id) => document.getElementById(id);
      let selectedProofFiles = [];
      let customerOptions = [];

      function setBusy(isBusy) {
        $("form").classList.toggle("busy", isBusy);
        $("authBlock").classList.toggle("busy", isBusy);
      }

      function setStatus(msg) { $("status").textContent = msg || ""; }
      function setError(msg) { $("error").textContent = msg || ""; }
      function setAuthError(msg) { $("authError").textContent = msg || ""; }
      function setSuccess(msg) { $("success").textContent = msg || ""; }
      function normalizeCustomerList(list) {
        const values = Array.isArray(list) ? list : [];
        const seen = new Map();

        for (const rawValue of values) {
          const value = String(rawValue || "").trim();
          if (!value) continue;
          const key = value.toLocaleLowerCase();
          if (!seen.has(key)) {
            seen.set(key, value);
          }
        }

        seen.delete(CUSTOMER_NOT_LISTED.toLocaleLowerCase());
        const sorted = Array.from(seen.values()).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: "base" }));
        return [CUSTOMER_NOT_LISTED, ...sorted];
      }
      async function fetchDefaultCustomerList() {
        const res = await fetch(DEFAULT_CUSTOMERS_URL, { headers: { "Accept": "application/json" } });
        if (!res.ok) {
          throw new Error(`Could not load default customers (HTTP ${res.status})`);
        }
        const data = await res.json();
        return normalizeCustomerList(data);
      }
      async function getBoardCustomerList() {
        const saved = await t.get("board", "shared", CUSTOMER_LIST_SETTINGS_KEY);
        if (Array.isArray(saved) && saved.length) {
          return normalizeCustomerList(saved);
        }
        return fetchDefaultCustomerList();
      }
      function renderCustomerOptions(list, selectedValue) {
        const select = $("companySelect");
        const previousValue = typeof selectedValue === "string" ? selectedValue : select.value;
        const normalized = normalizeCustomerList(list);
        customerOptions = normalized.slice();

        select.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select a customer...";
        select.appendChild(placeholder);

        for (const customer of customerOptions) {
          const opt = document.createElement("option");
          opt.value = customer;
          opt.textContent = customer;
          select.appendChild(opt);
        }

        if (previousValue && customerOptions.includes(previousValue)) {
          select.value = previousValue;
        } else if (previousValue === CUSTOMER_NOT_LISTED) {
          select.value = CUSTOMER_NOT_LISTED;
        } else {
          select.value = "";
        }

        updateCustomerSelectionUI();
      }
      function updateCustomerSelectionUI() {
        const isNotListed = $("companySelect").value === CUSTOMER_NOT_LISTED;
        $("companyCustomField").style.display = isNotListed ? "block" : "none";
        $("companyCustom").required = isNotListed;
        if (!isNotListed) {
          $("companyCustom").value = "";
        }
      }
      function getResolvedCustomerName() {
        const selected = String($("companySelect").value || "").trim();
        if (!selected) return "";
        if (selected === CUSTOMER_NOT_LISTED) {
          return String($("companyCustom").value || "").trim();
        }
        return selected;
      }
      async function saveBoardCustomerList(list) {
        const normalized = normalizeCustomerList(list);
        await t.set("board", "shared", CUSTOMER_LIST_SETTINGS_KEY, normalized);
        customerOptions = normalized.slice();
        return normalized;
      }
      async function maybeAddCustomerToBoardList(customerName) {
        const trimmed = String(customerName || "").trim();
        if (!trimmed || trimmed.toLocaleLowerCase() === CUSTOMER_NOT_LISTED.toLocaleLowerCase()) {
          return;
        }

        const current = customerOptions.length ? customerOptions.slice() : await getBoardCustomerList();
        const exists = current.some((item) => String(item).trim().toLocaleLowerCase() === trimmed.toLocaleLowerCase());
        if (exists) return;

        try {
          const updated = await saveBoardCustomerList([...current, trimmed]);
          renderCustomerOptions(updated, trimmed);
        } catch (e) {
          // Customer list auto-add is best effort and should not block approval submission.
        }
      }
      async function loadCustomerOptions() {
        try {
          const list = await getBoardCustomerList();
          renderCustomerOptions(list);
        } catch (e) {
          renderCustomerOptions([CUSTOMER_NOT_LISTED]);
          setError("Could not load customer list. You can still choose NOT LISTED and enter a customer name.");
        }
      }
      function getProofMethod() {
        return $("proofSign").checked ? PROOF_METHOD_SIGN : PROOF_METHOD_UPLOAD;
      }
      function isUploadProof() {
        return getProofMethod() === PROOF_METHOD_UPLOAD;
      }
      function updateProofMethodUI() {
        const uploadMode = isUploadProof();
        $("fileBlock").style.display = uploadMode ? "block" : "none";
        $("signBlock").style.display = uploadMode ? "none" : "block";
        $("dropZone").classList.toggle("disabled", !uploadMode);
        if (!uploadMode) {
          $("dropZone").classList.remove("active");
        }
      }
      function setSelectedProofFiles(files) {
        selectedProofFiles = Array.isArray(files) ? files.filter(Boolean) : [];
        if (!selectedProofFiles.length) {
          $("fileName").textContent = "";
          return;
        }

        if (selectedProofFiles.length === 1) {
          $("fileName").textContent = `Selected file: ${selectedProofFiles[0].name}`;
          return;
        }

        const previewNames = selectedProofFiles.slice(0, 3).map((file) => file.name).join(", ");
        const remainingCount = selectedProofFiles.length - 3;
        $("fileName").textContent =
          remainingCount > 0
            ? `Selected ${selectedProofFiles.length} files: ${previewNames}, +${remainingCount} more`
            : `Selected ${selectedProofFiles.length} files: ${previewNames}`;
      }
      function getSelectedProofFiles() {
        if (selectedProofFiles.length) return selectedProofFiles.slice();
        return Array.from(($("file").files || []));
      }
      function syncSelectedFilesFromInput() {
        setSelectedProofFiles(Array.from(($("file").files || [])));
      }
      function tryAssignInputFiles(files) {
        try {
          const dt = new DataTransfer();
          for (const file of files) {
            dt.items.add(file);
          }
          $("file").files = dt.files;
        } catch (e) {
          // Some environments block programmatic file assignment; we still track the dropped file in memory.
        }
      }
      function handleDroppedFiles(files) {
        const droppedFiles = Array.from(files || []).filter(Boolean);
        if (!droppedFiles.length || !isUploadProof()) return;
        tryAssignInputFiles(droppedFiles);
        setSelectedProofFiles(droppedFiles);
      }
      function wireDragAndDrop() {
        const dropZone = $("dropZone");
        const prevent = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };

        dropZone.addEventListener("click", () => {
          if (!isUploadProof()) return;
          $("file").click();
        });

        dropZone.addEventListener("keydown", (e) => {
          if (!isUploadProof()) return;
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            $("file").click();
          }
        });

        ["dragenter", "dragover"].forEach((eventName) => {
          dropZone.addEventListener(eventName, (e) => {
            prevent(e);
            if (!isUploadProof()) return;
            dropZone.classList.add("active");
          });
        });

        ["dragleave", "dragend"].forEach((eventName) => {
          dropZone.addEventListener(eventName, (e) => {
            prevent(e);
            dropZone.classList.remove("active");
          });
        });

        dropZone.addEventListener("drop", (e) => {
          prevent(e);
          dropZone.classList.remove("active");
          if (!isUploadProof()) return;

          const files = e.dataTransfer && e.dataTransfer.files;
          if (!files || !files.length) return;
          handleDroppedFiles(files);
        });
      }

      function isAppKeyConfigured() {
        return Boolean(APP_KEY);
      }

      async function clearStoredToken() {
        try {
          const client = await t.getRestApi();
          await client.clearToken();
        } catch (e) {
          // Swallow token-clear failures; auth retry should still be allowed.
        }
      }

      async function ensureAuthorized() {
        if (!isAppKeyConfigured()) {
          $("authBlock").style.display = "block";
          setAuthError("Power-Up app key is not configured. Update DEFAULT_APP_KEY in approval.html.");
          return false;
        }

        const client = await t.getRestApi();
        const ok = await client.isAuthorized();
        if (ok) return true;

        $("authBlock").style.display = "block";
        setAuthError("");

        return false;
      }

      async function doAuthorize() {
        setAuthError("");
        if (!isAppKeyConfigured()) {
          $("authBlock").style.display = "block";
          setAuthError("Power-Up app key is not configured. Update DEFAULT_APP_KEY in approval.html.");
          return false;
        }
        setBusy(true);
        try {
          const client = await t.getRestApi();
          // IMPORTANT: call authorize only from a user click handler
          await client.authorize({
            scope: "read,write",
            expiration: "never"
          });
          $("authBlock").style.display = "none";
          return true;
        } catch (e) {
          await clearStoredToken();
          setAuthError("Authorization was cancelled or failed.\n" + (e?.message || String(e)));
          return false;
        } finally {
          setBusy(false);
        }
      }

      function getMaxApprovalAttachmentIndex(existingAttachments) {
        // Support both old names ("_1") and current names (" 1").
        const re = new RegExp("^" + BASE_ATTACHMENT_NAME.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "(?:[ _](\\d+))?$");
        let maxN = -1;

        for (const a of existingAttachments) {
          const m = (a.name || "").match(re);
          if (!m) continue;
          if (!m[1]) maxN = Math.max(maxN, 0);
          else maxN = Math.max(maxN, parseInt(m[1], 10));
        }

        return maxN;
      }

      function computeNextAttachmentNames(existingAttachments, count) {
        const safeCount = Math.max(0, Number(count) || 0);
        if (!safeCount) return [];

        const maxN = getMaxApprovalAttachmentIndex(existingAttachments || []);
        let nextN = maxN < 0 ? 0 : maxN + 1;
        const names = [];

        for (let i = 0; i < safeCount; i += 1) {
          names.push(nextN === 0 ? BASE_ATTACHMENT_NAME : `${BASE_ATTACHMENT_NAME} ${nextN}`);
          nextN += 1;
        }

        return names;
      }

      async function trelloFetchJson(url, opts) {
        const res = await fetch(url, opts);
        const text = await res.text();
        let json;
        try { json = text ? JSON.parse(text) : null; } catch { json = null; }
        if (!res.ok) {
          const msg = json?.message || json?.error || text || `HTTP ${res.status}`;
          throw new Error(msg);
        }
        return json;
      }

      async function getToken() {
        const client = await t.getRestApi();
        const token = await client.getToken();
        if (!token) {
          throw new Error("Authorization token is missing. Click Authorize and try again.");
        }
        return token;
      }

      async function getCurrentMemberDisplayName() {
        try {
          const member = await t.member("fullName", "username");
          if (member?.fullName) return member.fullName;
          if (member?.username) return member.username;
        } catch (e) {
          // Fall back to API lookup below.
        }

        const token = await getToken();
        const url =
          `https://api.trello.com/1/members/me?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&fields=fullName,username`;
        const me = await trelloFetchJson(url, { method: "GET", headers: { "Accept": "application/json" } });
        return me?.fullName || me?.username || "A user";
      }

      async function getCardContext() {
        // Prefer explicit context passed from the card button callback.
        const argCardId = t.arg("cardId");
        const argBoardId = t.arg("boardId");
        if (argCardId && argBoardId) {
          return { cardId: argCardId, boardId: argBoardId };
        }

        // Fallback: fetch IDs from current Trello context.
        const [card, board] = await Promise.all([t.card("id"), t.board("id")]);
        if (!card?.id || !board?.id) {
          throw new Error("Could not resolve card context. Reopen from a card and try again.");
        }

        return { cardId: card.id, boardId: board.id };
      }

      async function getExistingAttachments(cardId, token) {
        const url = `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/attachments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}`;
        return trelloFetchJson(url, { method: "GET", headers: { "Accept": "application/json" } });
      }

      async function uploadAttachment(cardId, token, file, attachmentDisplayName) {
        // Create attachment using multipart form data plus display name.
        const url = `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/attachments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}&name=${encodeURIComponent(attachmentDisplayName)}`;

        const form = new FormData();
        // Trello expects multipart form data with "file"
        form.append("file", file, file.name);

        return trelloFetchJson(url, { method: "POST", body: form, headers: { "Accept": "application/json" } });
      }

      async function findOrCreateApprovedLabel(boardId, token) {
        // Get board labels, find exact match by name + green color (name matters more here)
        const listUrl = `https://api.trello.com/1/boards/${encodeURIComponent(boardId)}/labels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}`;
        const labels = await trelloFetchJson(listUrl, { method: "GET", headers: { "Accept": "application/json" } });

        const found = (labels || []).find(l =>
          (l.name || "").trim() === APPROVED_LABEL_NAME && (l.color || "").trim() === APPROVED_LABEL_COLOR
        );
        if (found?.id) return found.id;

        // Create label on board if it does not already exist.
        const createUrl =
          `https://api.trello.com/1/labels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&name=${encodeURIComponent(APPROVED_LABEL_NAME)}` +
          `&color=${encodeURIComponent(APPROVED_LABEL_COLOR)}` +
          `&idBoard=${encodeURIComponent(boardId)}`;

        const created = await trelloFetchJson(createUrl, { method: "POST", headers: { "Accept": "application/json" } });
        return created.id;
      }

      async function applyLabelToCard(cardId, labelId, token) {
        // Use the dedicated "add label" endpoint so we do not overwrite existing labels.
        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/idLabels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&value=${encodeURIComponent(labelId)}`;

        return trelloFetchJson(url, { method: "POST", headers: { "Accept": "application/json" } });
      }

      async function getDestinationConfig() {
        const saved = await t.get("board", "shared", DESTINATION_SETTINGS_KEY) || {};
        const configuredBoardId = String(saved.boardId || "").trim();
        const configuredListId = String(saved.listId || "").trim().replace(/^list-/, "");

        if (configuredListId) {
          return {
            boardId: configuredBoardId,
            listId: configuredListId
          };
        }

        return {
          boardId: "",
          listId: String(DEFAULT_TARGET_LIST_ID || "").trim().replace(/^list-/, "")
        };
      }

      async function moveCardToList(cardId, token, listId, configuredBoardId) {
        const normalizedListId = String(listId || "").replace(/^list-/, "");
        if (!normalizedListId) {
          throw new Error("Destination list ID is missing.");
        }

        // Resolve destination board from the destination list so cross-board moves succeed.
        const listUrl =
          `https://api.trello.com/1/lists/${encodeURIComponent(normalizedListId)}?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&fields=id,idBoard,name`;
        const list = await trelloFetchJson(listUrl, { method: "GET", headers: { "Accept": "application/json" } });
        if (!list?.idBoard) {
          throw new Error("Could not resolve destination board from target list.");
        }
        if (configuredBoardId && configuredBoardId !== list.idBoard) {
          throw new Error("Configured destination list does not belong to configured destination board. Open Power-Up settings and re-save destination.");
        }

        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&idBoard=${encodeURIComponent(list.idBoard)}` +
          `&idList=${encodeURIComponent(normalizedListId)}`;

        return trelloFetchJson(url, { method: "PUT", headers: { "Accept": "application/json" } });
      }

      async function addApprovalSignatureComment(cardId, token, signerName, designParts) {
        const safeSigner = (signerName || "A user").trim() || "A user";
        const safeParts = (designParts || "").trim();
        const commentLines = [
          `${safeSigner} has signed to confirm customer approval of this design.`,
          safeParts ? `Approved design parts/numbers: ${safeParts}` : ""
        ].filter(Boolean);
        const commentText = commentLines.join("\n");

        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/actions/comments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&text=${encodeURIComponent(commentText)}`;

        return trelloFetchJson(url, { method: "POST", headers: { "Accept": "application/json" } });
      }

      async function addApprovalUploadComment(cardId, token, signerName, designParts, attachmentNames) {
        const safeSigner = (signerName || "A user").trim() || "A user";
        const safeParts = (designParts || "").trim();
        const safeNames = Array.isArray(attachmentNames) ? attachmentNames.filter(Boolean) : [];
        const commentLines = [
          `${safeSigner} has uploaded customer approval for parts/numbers: ${safeParts}.`,
          safeNames.length ? `Approval proof file${safeNames.length === 1 ? "" : "s"}: ${safeNames.join(", ")}` : ""
        ].filter(Boolean);
        const commentText = commentLines.join("\n");

        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/actions/comments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&text=${encodeURIComponent(commentText)}`;

        return trelloFetchJson(url, { method: "POST", headers: { "Accept": "application/json" } });
      }

      async function saveApprovalMeta(company, contact, designParts, proofMethod, attachmentNames, signerName) {
        // Optional but great for accountability/auditing inside the Power-Up.
        try {
          const normalizedAttachmentNames = Array.isArray(attachmentNames) ? attachmentNames.filter(Boolean) : [];
          await t.set("card", "shared", "customerApproval", {
            approved: true,
            company,
            contact,
            designParts,
            proofMethod,
            signerName: signerName || "",
            attachmentName: normalizedAttachmentNames[0] || "",
            attachmentNames: normalizedAttachmentNames,
            approvedAt: new Date().toISOString()
          });
        } catch (e) {
          // Do not fail the workflow if plugin-data write is unavailable.
        }
      }

      // Wire up buttons
      $("btnClose").addEventListener("click", () => t.closeModal());
      $("btnCloseA").addEventListener("click", () => t.closeModal());
      $("companySelect").addEventListener("change", updateCustomerSelectionUI);
      $("proofUpload").addEventListener("change", updateProofMethodUI);
      $("proofSign").addEventListener("change", updateProofMethodUI);
      $("file").addEventListener("change", syncSelectedFilesFromInput);
      $("btnAuthorize").addEventListener("click", async () => {
        const ok = await doAuthorize();
        if (ok) $("authBlock").style.display = "none";
      });
      wireDragAndDrop();
      updateProofMethodUI();

      // On render, show auth UI if needed
      t.render(async () => {
        try {
          await loadCustomerOptions();
          await ensureAuthorized();
        }
        catch (e) { /* ignore */ }
      });

      $("form").addEventListener("submit", async (e) => {
        e.preventDefault();
        setError("");
        setSuccess("");

        const approved = $("approved").checked;
        const companySelection = String($("companySelect").value || "").trim();
        const company = getResolvedCustomerName();
        const contact = $("contact").value.trim();
        const designParts = $("designParts").value.trim();
        const proofMethod = getProofMethod();
        const files = getSelectedProofFiles();

        const problems = [];
        if (!approved) problems.push("- You must confirm the customer approved the design.");
        if (!companySelection) problems.push("- Customer Name is required.");
        if (companySelection === CUSTOMER_NOT_LISTED && !company) problems.push("- Enter Customer Name is required when NOT LISTED is selected.");
        if (!contact) problems.push("- Customer Contact Name is required.");
        if (!designParts) problems.push("- Design Part Name(s) / Number(s) is required.");
        if (proofMethod === PROOF_METHOD_UPLOAD && !files.length) {
          problems.push("- You must upload at least one approval file, or choose the digital signature option.");
        }

        if (problems.length) {
          setError("Please fix the following:\n" + problems.join("\n"));
          return;
        }

        setBusy(true);
        try {
          // Ensure authorized
          const client = await t.getRestApi();
          const isAuthed = await client.isAuthorized();
          if (!isAuthed) {
            $("authBlock").style.display = "block";
            setError("Authorization is required before uploading.");
            return;
          }

          setStatus("Preparing upload...");
          const token = await getToken();
          const { cardId, boardId } = await getCardContext();

          // Determine next attachment name
          let attachmentDisplayNames = [];
          let signerName = "";
          if (proofMethod === PROOF_METHOD_UPLOAD) {
            setStatus("Checking existing attachments...");
            const existing = await getExistingAttachments(cardId, token);
            attachmentDisplayNames = computeNextAttachmentNames(existing || [], files.length);
            signerName = await getCurrentMemberDisplayName();

            // Upload attachment(s)
            for (let i = 0; i < files.length; i += 1) {
              const attachmentDisplayName = attachmentDisplayNames[i];
              setStatus(`Uploading file ${i + 1} of ${files.length} as "${attachmentDisplayName}"...`);
              await uploadAttachment(cardId, token, files[i], attachmentDisplayName);
            }

            setStatus("Adding upload comment...");
            await addApprovalUploadComment(cardId, token, signerName, designParts, attachmentDisplayNames);
          } else {
            setStatus("Adding digital signature comment...");
            signerName = await getCurrentMemberDisplayName();
            await addApprovalSignatureComment(cardId, token, signerName, designParts);
          }

          // Label: find/create then apply
          setStatus('Applying "Customer Approved" label...');
          const labelId = await findOrCreateApprovedLabel(boardId, token);
          await applyLabelToCard(cardId, labelId, token);

          // Move card to the configured destination list.
          setStatus("Moving card to destination list...");
          const destination = await getDestinationConfig();
          await moveCardToList(cardId, token, destination.listId, destination.boardId);

          // Save meta
          setStatus("Saving verification details...");
          await saveApprovalMeta(company, contact, designParts, proofMethod, attachmentDisplayNames, signerName);
          if (companySelection === CUSTOMER_NOT_LISTED) {
            await maybeAddCustomerToBoardList(company);
          }

          if (proofMethod === PROOF_METHOD_UPLOAD) {
            setSuccess("Done. Approval proof uploaded, comment added, card marked Customer Approved, and moved to the destination list.");
          } else {
            setSuccess("Done. Digital signature comment added, card marked Customer Approved, and moved to the destination list.");
          }
          setStatus("");

          // Close after a beat so user sees success
          setTimeout(() => t.closeModal(), 700);
        } catch (err) {
          setStatus("");
          setError(err?.message || String(err));
        } finally {
          setBusy(false);
        }
      });
    </script>
  </body>
</html>
