<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Customer Approval</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 14px; }
      .field { margin-bottom: 12px; }
      label { display:block; font-size: 13px; margin-bottom: 6px; }
      input[type="text"] { width: 100%; padding: 8px; box-sizing: border-box; }
      input[type="file"] { width: 100%; }
      .row { display:flex; gap: 10px; }
      .row > div { flex: 1; }
      .actions { display:flex; gap: 10px; margin-top: 14px; }
      button { padding: 9px 12px; cursor: pointer; }
      .error { color: #b42318; font-size: 13px; margin-top: 8px; white-space: pre-line; }
      .note { color:#d1d1d1; font-size: 12px; margin-top: 6px; }
      .busy { opacity: 0.7; pointer-events:none; }
      .success { color: #1f7a1f; font-size: 13px; margin-top: 8px; }
      .hr { height: 1px; background: #e6e6e6; margin: 12px 0; }
    </style>
  </head>
  <body>
    <div id="authBlock" class="field" style="display:none;">
      <div class="note">
        This Power-Up needs permission to upload attachments and apply labels.
      </div>
      <div class="actions">
        <button id="btnAuthorize" type="button">Authorize</button>
        <button id="btnCloseA" type="button">Close</button>
      </div>
      <div id="authError" class="error"></div>
      <div class="hr"></div>
    </div>

    <form id="form">
      <div class="field">
        <label>
          <input id="approved" type="checkbox" required />
          This design has been approved by the customer
        </label>
      </div>

      <div class="row">
        <div class="field">
          <label for="company">Customer Company (required)</label>
          <input id="company" type="text" required />
        </div>
        <div class="field">
          <label for="contact">Customer Contact Name (required)</label>
          <input id="contact" type="text" required />
        </div>
      </div>

      <div class="field">
        <label for="file">Upload approval file (required)</label>
        <input id="file" type="file" required />
        <div class="note">This can be a signed print, screenshot of an email, or similar proof of customer approval.</div>
        <div class="note">This will be attached to the card as "Customer Approval Verification".</div>
      </div>

      <div class="actions">
        <button id="btnSubmit" type="submit">Mark Approved & Upload</button>
        <button id="btnClose" type="button">Cancel</button>
      </div>

      <div id="status" class="note"></div>
      <div id="error" class="error"></div>
      <div id="success" class="success"></div>
    </form>

    <script src="https://p.trellocdn.com/power-up.min.js"></script>
    <script>
      const DEFAULT_APP_KEY = "51c30a2cb14666510ff4905d9d4eae07";
      const APP_KEY = new URLSearchParams(window.location.search).get("appKey") || DEFAULT_APP_KEY;
      const APP_NAME = "Customer Approval Gatekeeper";
      const APP_AUTHOR = "Syllable Agency";

      const BASE_ATTACHMENT_NAME = "Customer Approval Verification";
      const APPROVED_LABEL_NAME = "Customer Approved";
      const APPROVED_LABEL_COLOR = "green";
      const TARGET_LIST_ID = "5d1393e0184e28237c1a59a6";

      const t = window.TrelloPowerUp.iframe({
        appKey: APP_KEY,
        appName: APP_NAME,
        appAuthor: APP_AUTHOR
      });

      const $ = (id) => document.getElementById(id);

      function setBusy(isBusy) {
        $("form").classList.toggle("busy", isBusy);
        $("authBlock").classList.toggle("busy", isBusy);
      }

      function setStatus(msg) { $("status").textContent = msg || ""; }
      function setError(msg) { $("error").textContent = msg || ""; }
      function setAuthError(msg) { $("authError").textContent = msg || ""; }
      function setSuccess(msg) { $("success").textContent = msg || ""; }

      function isAppKeyConfigured() {
        return Boolean(APP_KEY);
      }

      async function clearStoredToken() {
        try {
          const client = await t.getRestApi();
          await client.clearToken();
        } catch (e) {
          // Swallow token-clear failures; auth retry should still be allowed.
        }
      }

      async function ensureAuthorized() {
        if (!isAppKeyConfigured()) {
          $("authBlock").style.display = "block";
          setAuthError("Power-Up app key is not configured. Update DEFAULT_APP_KEY in approval.html.");
          return false;
        }

        const client = await t.getRestApi();
        const ok = await client.isAuthorized();
        if (ok) return true;

        $("authBlock").style.display = "block";
        setAuthError("");

        return false;
      }

      async function doAuthorize() {
        setAuthError("");
        if (!isAppKeyConfigured()) {
          $("authBlock").style.display = "block";
          setAuthError("Power-Up app key is not configured. Update DEFAULT_APP_KEY in approval.html.");
          return false;
        }
        setBusy(true);
        try {
          const client = await t.getRestApi();
          // IMPORTANT: call authorize only from a user click handler
          await client.authorize({
            scope: "read,write",
            expiration: "never"
          });
          $("authBlock").style.display = "none";
          return true;
        } catch (e) {
          await clearStoredToken();
          setAuthError("Authorization was cancelled or failed.\n" + (e?.message || String(e)));
          return false;
        } finally {
          setBusy(false);
        }
      }

      function computeNextAttachmentName(existingAttachments) {
        // Count attachments whose display name matches:
        // Customer Approval Verification
        // Customer Approval Verification_1
        // Customer Approval Verification_2
        // ...
        const re = new RegExp("^" + BASE_ATTACHMENT_NAME.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "(?:_(\\d+))?$");
        let maxN = -1;

        for (const a of existingAttachments) {
          const m = (a.name || "").match(re);
          if (!m) continue;
          if (!m[1]) maxN = Math.max(maxN, 0);
          else maxN = Math.max(maxN, parseInt(m[1], 10));
        }

        if (maxN < 0) return BASE_ATTACHMENT_NAME;      // none exist
        if (maxN === 0) return BASE_ATTACHMENT_NAME + "_1"; // base exists, next is _1
        return BASE_ATTACHMENT_NAME + "_" + (maxN + 1);
      }

      async function trelloFetchJson(url, opts) {
        const res = await fetch(url, opts);
        const text = await res.text();
        let json;
        try { json = text ? JSON.parse(text) : null; } catch { json = null; }
        if (!res.ok) {
          const msg = json?.message || json?.error || text || `HTTP ${res.status}`;
          throw new Error(msg);
        }
        return json;
      }

      async function getToken() {
        const client = await t.getRestApi();
        const token = await client.getToken();
        if (!token) {
          throw new Error("Authorization token is missing. Click Authorize and try again.");
        }
        return token;
      }

      async function getCardContext() {
        // Prefer explicit context passed from the card button callback.
        const argCardId = t.arg("cardId");
        const argBoardId = t.arg("boardId");
        if (argCardId && argBoardId) {
          return { cardId: argCardId, boardId: argBoardId };
        }

        // Fallback: fetch IDs from current Trello context.
        const [card, board] = await Promise.all([t.card("id"), t.board("id")]);
        if (!card?.id || !board?.id) {
          throw new Error("Could not resolve card context. Reopen from a card and try again.");
        }

        return { cardId: card.id, boardId: board.id };
      }

      async function getExistingAttachments(cardId, token) {
        const url = `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/attachments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}`;
        return trelloFetchJson(url, { method: "GET", headers: { "Accept": "application/json" } });
      }

      async function uploadAttachment(cardId, token, file, attachmentDisplayName) {
        // Create attachment using multipart form data plus display name.
        const url = `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/attachments?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}&name=${encodeURIComponent(attachmentDisplayName)}`;

        const form = new FormData();
        // Trello expects multipart form data with "file"
        form.append("file", file, file.name);

        return trelloFetchJson(url, { method: "POST", body: form, headers: { "Accept": "application/json" } });
      }

      async function findOrCreateApprovedLabel(boardId, token) {
        // Get board labels, find exact match by name + green color (name matters more here)
        const listUrl = `https://api.trello.com/1/boards/${encodeURIComponent(boardId)}/labels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}`;
        const labels = await trelloFetchJson(listUrl, { method: "GET", headers: { "Accept": "application/json" } });

        const found = (labels || []).find(l =>
          (l.name || "").trim() === APPROVED_LABEL_NAME && (l.color || "").trim() === APPROVED_LABEL_COLOR
        );
        if (found?.id) return found.id;

        // Create label on board if it does not already exist.
        const createUrl =
          `https://api.trello.com/1/labels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&name=${encodeURIComponent(APPROVED_LABEL_NAME)}` +
          `&color=${encodeURIComponent(APPROVED_LABEL_COLOR)}` +
          `&idBoard=${encodeURIComponent(boardId)}`;

        const created = await trelloFetchJson(createUrl, { method: "POST", headers: { "Accept": "application/json" } });
        return created.id;
      }

      async function applyLabelToCard(cardId, labelId, token) {
        // Use the dedicated "add label" endpoint so we do not overwrite existing labels.
        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}/idLabels?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&value=${encodeURIComponent(labelId)}`;

        return trelloFetchJson(url, { method: "POST", headers: { "Accept": "application/json" } });
      }

      async function moveCardToList(cardId, token, listId) {
        const normalizedListId = String(listId || "").replace(/^list-/, "");
        if (!normalizedListId) {
          throw new Error("Destination list ID is missing.");
        }

        // Resolve destination board from the destination list so cross-board moves succeed.
        const listUrl =
          `https://api.trello.com/1/lists/${encodeURIComponent(normalizedListId)}?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&fields=id,idBoard,name`;
        const list = await trelloFetchJson(listUrl, { method: "GET", headers: { "Accept": "application/json" } });
        if (!list?.idBoard) {
          throw new Error("Could not resolve destination board from target list.");
        }

        const url =
          `https://api.trello.com/1/cards/${encodeURIComponent(cardId)}?key=${encodeURIComponent(APP_KEY)}&token=${encodeURIComponent(token)}` +
          `&idBoard=${encodeURIComponent(list.idBoard)}` +
          `&idList=${encodeURIComponent(normalizedListId)}`;

        return trelloFetchJson(url, { method: "PUT", headers: { "Accept": "application/json" } });
      }

      async function saveApprovalMeta(company, contact, attachmentName) {
        // Optional but great for accountability/auditing inside the Power-Up.
        try {
          await t.set("card", "shared", "customerApproval", {
            approved: true,
            company,
            contact,
            attachmentName,
            approvedAt: new Date().toISOString()
          });
        } catch (e) {
          // Do not fail the workflow if plugin-data write is unavailable.
        }
      }

      // Wire up buttons
      $("btnClose").addEventListener("click", () => t.closeModal());
      $("btnCloseA").addEventListener("click", () => t.closeModal());
      $("btnAuthorize").addEventListener("click", async () => {
        const ok = await doAuthorize();
        if (ok) $("authBlock").style.display = "none";
      });

      // On render, show auth UI if needed
      t.render(async () => {
        try { await ensureAuthorized(); }
        catch (e) { /* ignore */ }
      });

      $("form").addEventListener("submit", async (e) => {
        e.preventDefault();
        setError("");
        setSuccess("");

        const approved = $("approved").checked;
        const company = $("company").value.trim();
        const contact = $("contact").value.trim();
        const file = $("file").files && $("file").files[0];

        const problems = [];
        if (!approved) problems.push("- You must confirm the customer approved the design.");
        if (!company) problems.push("- Customer Company is required.");
        if (!contact) problems.push("- Customer Contact Name is required.");
        if (!file) problems.push("- You must upload an approval file.");

        if (problems.length) {
          setError("Please fix the following:\n" + problems.join("\n"));
          return;
        }

        setBusy(true);
        try {
          // Ensure authorized
          const client = await t.getRestApi();
          const isAuthed = await client.isAuthorized();
          if (!isAuthed) {
            $("authBlock").style.display = "block";
            setError("Authorization is required before uploading.");
            return;
          }

          setStatus("Preparing upload...");
          const token = await getToken();
          const { cardId, boardId } = await getCardContext();

          // Determine next attachment name
          setStatus("Checking existing attachments...");
          const existing = await getExistingAttachments(cardId, token);
          const attachmentDisplayName = computeNextAttachmentName(existing || []);

          // Upload attachment
          setStatus(`Uploading as "${attachmentDisplayName}"...`);
          await uploadAttachment(cardId, token, file, attachmentDisplayName);

          // Label: find/create then apply
          setStatus('Applying "Customer Approved" label...');
          const labelId = await findOrCreateApprovedLabel(boardId, token);
          await applyLabelToCard(cardId, labelId, token);

          // Move card to Document Control destination list.
          setStatus("Moving card to Document Control...");
          await moveCardToList(cardId, token, TARGET_LIST_ID);

          // Save meta
          setStatus("Saving verification details...");
          await saveApprovalMeta(company, contact, attachmentDisplayName);

          setSuccess("Done. Attachment uploaded, card marked Customer Approved, and moved to Document Control.");
          setStatus("");

          // Close after a beat so user sees success
          setTimeout(() => t.closeModal(), 700);
        } catch (err) {
          setStatus("");
          setError(err?.message || String(err));
        } finally {
          setBusy(false);
        }
      });
    </script>
  </body>
</html>
